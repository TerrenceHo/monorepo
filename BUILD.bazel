load("@gazelle//:def.bzl", "DEFAULT_LANGUAGES", "gazelle", "gazelle_binary")
load("@pypi//:requirements.bzl", "all_data_requirements", "all_requirements", "all_whl_requirements", "requirement")
load("@python_versions//3.13:defs.bzl", compile_pip_requirements_3_13 = "compile_pip_requirements")
load("@rules_multirun//:defs.bzl", "command", "multirun")
load("@rules_python_gazelle_plugin//manifest:defs.bzl", "gazelle_python_manifest")
load("@rules_python_gazelle_plugin//modules_mapping:def.bzl", "modules_mapping")

##### Gazelle configration options
# https://github.com/bazelbuild/bazel-gazelle#running-gazelle-with-bazel
# gazelle:prefix github.com/TerrenceHo/monorepo
# gazelle:build_file_name BUILD.bazel
#
# Exclusions
# gazelle:exclude */vendor
# gazelle:exclude .bazel
# gazelle:exclude bazel-out
# gazelle:exclude **/node_modules
# gazelle:exclude third_party
# gazelle:exclude *_test.go

# Being explicit about naming conventions
# gazelle:go_naming_convention import
# gazelle:go_naming_convention_external import

# gazelle:map_kind go_binary go_binary //bazel/go:default.bzl
# gazelle:map_kind go_library go_library //bazel/go:default.bzl
# gazelle:map_kind go_test go_test //bazel/go:default.bzl

# gazelle:map_kind py_binary py_binary //bazel/python:rules.bzl
# gazelle:map_kind py_library py_library //bazel/python:rules.bzl
# gazelle:map_kind py_test py_test //bazel/python:rules.bzl

# For each Python project, add it as a root, so that the imports don't have to
# be relative from the root of the monorepo, which makes it more Pythonic in
# terms of classic project setup.
# gazelle:python_root //example-python

gazelle_binary(
    name = "gazelle_multilang",
    languages = [
        "@rules_python_gazelle_plugin//python",
    ] + DEFAULT_LANGUAGES,
)

gazelle(
    name = "gazelle",
    gazelle = ":gazelle_multilang",
)

# check_build_files diffs which BUILD files are going to change. Exits with code
# 1 if files need to change, else code 0.
# gazelle(
#     name = "check_build_files",
#     command = "update",
#     extra_args = [
#         "-mode",
#         "diff",
#     ],
#     gazelle = "//:gazelle_binary",
# )

# update_go_deps is a convenience target. See
# https://github.com/bazelbuild/bazel-gazelle#update-repos.
gazelle(
    name = "update_go_deps",
    args = [
        "-to_macro=bazel/go/deps.bzl%fetch_go_deps",
        "-from_file=go.mod",
        # -build_file_proto_mod=disable_global is set so that all pregenerated
        # pb.go files are used for all external repos. Prevents lots of
        # warnings.
        # "-build_file_proto_mode=disable_global",
        "-prune=true",
    ],
    command = "update-repos",
    gazelle = ":gazelle_multiland",
)

##### CI Rules
# run all image pushing rules in parallel using multirun
multirun(
    name = "push_all",
    commands = [
        "//fastlinks/cmd/fastlinks:push",
    ],
    jobs = 0,
)

##########
# Python #
##########
compile_pip_requirements_3_13(
    name = "requirements_3_13",
    src = "requirements_3_13.in",
    requirements_txt = "requirements_lock_3_13.txt",
)

##################
# Python Gazelle #
##################

# This rule fetches the metadata for python packages we depend on. That data is
# required for the gazelle_python_manifest rule to update our manifest file.
modules_mapping(
    name = "modules_map",
    include_stub_packages = True,
    wheels = all_whl_requirements,
)

# Gazelle python extension needs a manifest file mapping from
# an import to the installed package that provides it.
# This macro produces two targets:
# - //:gazelle_python_manifest.update can be used with `bazel run`
#   to recalculate the manifest
# - //:gazelle_python_manifest.test is a test target ensuring that
#   the manifest doesn't need to be updated
gazelle_python_manifest(
    name = "gazelle_python_manifest",
    modules_mapping = ":modules_map",

    # This is what we called our `pip.parse` rule in MODULE.bazel, where third-party
    # python libraries are loaded in BUILD files.
    pip_repository_name = "pypi",

    # This should point to wherever we declare our python dependencies
    # (the same as what we passed to the modules_mapping rule in WORKSPACE)
    # This argument is optional. If provided, the `.test` target is very
    # fast because it just has to check an integrity field. If not provided,
    # the integrity field is not added to the manifest which can help avoid
    # merge conflicts in large repos.
    requirements = "//:requirements_lock_3_13.txt",
)
